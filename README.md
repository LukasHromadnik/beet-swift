# Solita Swift [![Swift](https://github.com/metaplex-foundation/solita-swift/actions/workflows/swift.yml/badge.svg)](https://github.com/metaplex-foundation/solita-swift/actions/workflows/swift.yml)

**Sol** ana **I** DL **t** o **A** PI generator.

## How does it Work?

_Solita_ generates a Swift SDK for your _Solana_ Rust programs from the [IDL](https://en.wikipedia.org/wiki/Interface_description_language) extracted by
[anchor](https://github.com/project-serum/anchor).

It supports Anchor/Shank IDls and will output a SPM package generated. It includes Accounts, Errors, Instructions and Types. It uses a a default borsch serializer called `beet` also included in the package.

Its a carbon copy from [Solita](https://github.com/metaplex-foundation/solita) with lots of language specific considerations. IDL processing and architecture has been maintained.

## Usage

Run solita cli against the idl.json generated by shank or solita

```sh
solita render <idlPath> <outputDir>
```
For example 

```sh
solita render Tests/SolitaTests/Resources/action_house.json .output
```

This will generate a swift package that contains a swift package of a library target. By default the target is called `Generated`. The package will contain the necessary dependencies to run the library that can be embedded into any project. Inside you will also get all the `Sources` of this generated code for this idl. 

To change the package name please provide the package name option `-p <packageName>`

```sh
solita render Tests/SolitaTests/Resources/action_house.json .output -p ActionHouse
```

Inside the `Sources` you will also get a `.swiftlint` that have the following disabled_rules. 

```yaml
disabled_rules:
 - identifier_name
 - force_cast
```

Currently there is no way to change the name scheme for the identifiers. Casting is also necessary since the parsing requires it.

Please verify your `Program.swift` and check if is pointing to the default onchain program. If the publicKey is provided by the IDL it will be shown here. If is not, please provided it or it will throw an exception during runtime.

```swift
import Foundation
import Solana

/**
* Program address
*
* @category constants
* @category generated
*/

let PROGRAM_ADDRESS = "<publickey>"

/**
* Program public key
*
* @category constants
* @category generated
*/

public let PROGRAM_ID = PublicKey(string: PROGRAM_ADDRESS)
```
# Beet Swift

Its a port of [Beet](https://github.com/metaplex-foundation/beet/tree/master/beet#features), Strict borsh compatible de/serializer. It can be used as a stand alone library. Its the main serializer for Solita

## Features

It supports 

- fully composable, i.e. `coption(inner: Beet.fixedBeet(.init(value: .scalar(i64()))))` is handled correctly
- structs can be nested and composed
- pre-computes `byteSize` of any fixed size type, no matter how deeply nested or composed it is
- converts non-fixed types to their fixed versions simply by providing a value or serialized
  data
- fixed size and _fixable_ structs expose identical serialize/deserialize API and perform
  conversions under the hood when needed

## Fixed Size vs. Dynamic Types 

Beet is optimized for _fixed_ types as this allows logging detailed diagnostics about the
structure of data that it is processing as well as avoiding Buffer resizes.

Only _beets_ that have _fixed_ in the name are of fixed size, all others are _fixable_ types
which expose `toFixedFromData` and `toFixedFromValue` methods to convert to a _fixed beet_ from
serialized data or a value respectively.

Beet provides the `FixableBeetStruct` to de/serialize arguments (dictionaries) that have non-fixed size fields. 

Beet implements the entire [borsh spec](https://borsh.io/). 

## Examples

### Single Fixed Struct Configuration
```swift
import Beet

struct Results: Equatable {
    let win: UInt8
    let totalWin: UInt16
    let losses: Int32
    
    static let `struct` = BeetStruct(
        fields: [
            ("win", FixedSizeBeet(value: .scalar(u8()))),
            ("totalWin", FixedSizeBeet(value:.scalar(u16()))),
            ("losses", FixedSizeBeet(value: .scalar(i32())))
        ],
        construct: { args in
            Results(
                win: args["win"] as! UInt8,
                totalWin: args["totalWin"] as! UInt16,
                losses: args["losses"] as! Int32
            )
        },
        description: "Results"
    )
}
```

### Nested Struct Configuration
```swift
import Beet
import Solana

struct Trader: Equatable {
    let name: String
    let results: Results
    let age: UInt8
    
    static let `struct` = BeetStruct(
        fields: [
            ("name", FixedSizeBeet(value: .collection(FixedSizeUtf8String(stringByteLength: 4)))),
            ("results", FixedSizeBeet(value:.scalar(Results.struct))),
            ("age", FixedSizeBeet(value: .scalar(u8())))
        ],
        construct: { args in
            Trader(
                name: args["name"] as! String,
                results: args["results"] as! Results,
                age: args["age"] as! UInt8
            )
        },
        description: "Trader"
    )
}

let trader = Trader(name: "bob ", results: Results(win: 20, totalWin: 1200, losses: -455), age: 22)
let (buf,_) = Trader.struct.serialize(instance: trader, byteSize: Int(Trader.struct.byteSize))
let (deserialized, _) = Trader.struct.deserialize(buffer: buf)
```

### Struct with non-primitive fields
```swift
import Beet
import Solana

```
## LICENSE

Apache-2.0
